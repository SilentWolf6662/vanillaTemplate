"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TailwindNodesManager = exports.isUnresolvedTailwindNode = exports.isResolvedTailwindNode = void 0;
const postcss_1 = require("postcss");
const isAtRuleNode_1 = require("./utils/isAtRuleNode");
const isChildNode_1 = require("./utils/isChildNode");
function isResolvedTailwindNode(node) {
    return 'rule' in node;
}
exports.isResolvedTailwindNode = isResolvedTailwindNode;
function isUnresolvedTailwindNode(node) {
    return !isResolvedTailwindNode(node);
}
exports.isUnresolvedTailwindNode = isUnresolvedTailwindNode;
class TailwindNodesManager {
    constructor(initialNodes) {
        this.nodesMap = new Map();
        if (initialNodes === null || initialNodes === void 0 ? void 0 : initialNodes.length) {
            this.mergeNodes(initialNodes);
        }
    }
    mergeNode(node) {
        const nodeIsResolved = isResolvedTailwindNode(node);
        const nodeKey = nodeIsResolved
            ? TailwindNodesManager.convertRuleToKey(node.rule)
            : node.key;
        const foundNode = this.nodesMap.get(nodeKey);
        if (foundNode) {
            foundNode.tailwindClasses = foundNode.tailwindClasses.concat(nodeIsResolved
                ? node.tailwindClasses
                : node.tailwindClasses.map(className => `${node.classesPrefix}${className}`));
            return;
        }
        if (nodeIsResolved) {
            this.nodesMap.set(nodeKey, node);
        }
        else {
            let rule;
            if (node.rootRuleSelector) {
                rule = new postcss_1.Rule({
                    selector: node.rootRuleSelector,
                });
                const rootChild = this.upToRootChild(node.originalRule);
                if (rootChild) {
                    node.originalRule.root().insertBefore(rootChild, rule);
                }
            }
            else {
                rule = node.originalRule;
            }
            this.nodesMap.set(nodeKey, {
                rule,
                tailwindClasses: node.tailwindClasses.map(className => `${node.classesPrefix}${className}`),
            });
        }
    }
    mergeNodes(nodes) {
        nodes.forEach(node => {
            this.mergeNode(node);
        });
    }
    hasNode(key) {
        return this.nodesMap.has(key);
    }
    getNode(key) {
        return this.nodesMap.get(key) || null;
    }
    getNodes() {
        return Array.from(this.nodesMap.values());
    }
    upToRootChild(node) {
        let childNode = null;
        while (node.parent &&
            node.parent.type !== 'root' &&
            (0, isChildNode_1.isChildNode)(node.parent)) {
            childNode = node = node.parent;
            continue;
        }
        return childNode;
    }
    static convertRuleToKey(rule, overriddenSelector = null) {
        let currentParent = rule.parent;
        let parentKey = '';
        while ((0, isChildNode_1.isChildNode)(currentParent)) {
            parentKey +=
                ((0, isAtRuleNode_1.isAtRuleNode)(currentParent)
                    ? this.makeSingleAtRuleKey(currentParent)
                    : this.makeSingleRuleKey(currentParent)) + '__';
            currentParent = currentParent.parent;
        }
        return (parentKey +
            (overriddenSelector == null ? rule.selector : overriddenSelector));
    }
    static makeSingleAtRuleKey(atRule) {
        return 'a(' + atRule.name + '|' + atRule.params + ')';
    }
    static makeSingleRuleKey(atRule) {
        return 'r(' + atRule.selector + ')';
    }
}
exports.TailwindNodesManager = TailwindNodesManager;
