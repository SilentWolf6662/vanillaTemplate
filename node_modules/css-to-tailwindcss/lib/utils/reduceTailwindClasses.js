"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reduceTailwindClasses = void 0;
const isObject_1 = require("./isObject");
class TailwindClassesReductionManager {
    constructor() {
        this.resolvedClasses = [];
        this.map = {
            m: { mx: { ml: [], mr: [] }, my: { mt: [], mb: [] } },
            p: { px: { pl: [], pr: [] }, py: { pt: [], pb: [] } },
            'scroll-m': {
                'scroll-mx': {
                    'scroll-ml': [],
                    'scroll-mr': [],
                },
                'scroll-my': {
                    'scroll-mt': [],
                    'scroll-mb': [],
                },
            },
            'scroll-p': {
                'scroll-px': {
                    'scroll-pl': [],
                    'scroll-pr': [],
                },
                'scroll-py': {
                    'scroll-pt': [],
                    'scroll-pb': [],
                },
            },
            rounded: {
                'rounded-t': {
                    'rounded-tl': [],
                    'rounded-tr': [],
                },
                'rounded-r': {
                    'rounded-tr': [],
                    'rounded-br': [],
                },
                'rounded-b': {
                    'rounded-bl': [],
                    'rounded-br': [],
                },
                'rounded-l': {
                    'rounded-tl': [],
                    'rounded-bl': [],
                },
            },
            border: {
                'border-x': {
                    'border-l': [],
                    'border-r': [],
                },
                'border-y': {
                    'border-t': [],
                    'border-b': [],
                },
            },
            scale: {
                'scale-x': [],
                'scale-y': [],
            },
            inset: {
                'inset-x': {
                    left: [],
                    right: [],
                },
                'inset-y': {
                    top: [],
                    bottom: [],
                },
            },
        };
    }
    appendClassName(className) {
        const { value, classPrefix } = this.parseTailwindClass(className);
        if (!value || !this.recursiveSetValue(classPrefix, value, this.map)) {
            this.resolvedClasses.push(className);
        }
    }
    reduce() {
        Object.keys(this.map).forEach(mapKey => {
            this.recursiveResolveClasses(this.map[mapKey], this.resolvedClasses).forEach((_, value) => {
                this.resolvedClasses.push(this.toTailwindClass(mapKey, value));
            });
        });
        return this.resolvedClasses;
    }
    recursiveSetValue(key, value, targetObject) {
        for (let objectKey in targetObject) {
            if (!Object.prototype.hasOwnProperty.call(targetObject, objectKey))
                continue;
            const objectValue = targetObject[objectKey];
            if (objectKey === key) {
                if ((0, isObject_1.isObject)(objectValue)) {
                    this.recursiveSetValueToAllKeys(value, objectValue);
                }
                else if (Array.isArray(objectValue)) {
                    objectValue.push(value);
                }
                return true;
            }
            if ((0, isObject_1.isObject)(objectValue)) {
                const isSet = this.recursiveSetValue(key, value, objectValue);
                if (isSet) {
                    return true;
                }
            }
        }
        return false;
    }
    recursiveSetValueToAllKeys(value, targetObject) {
        Object.keys(targetObject).forEach(key => {
            this.recursiveSetValue(key, value, targetObject);
        });
    }
    recursiveResolveClasses(targetObject, resolvedClasses) {
        let commonValuesMap = null;
        const intersectCommonValues = (valuesMap) => {
            if (commonValuesMap == null) {
                commonValuesMap = valuesMap;
            }
            else {
                commonValuesMap.forEach((commonClassPrefix, commonValue) => {
                    const classPrefix = valuesMap.get(commonValue);
                    if (classPrefix) {
                        commonValuesMap === null || commonValuesMap === void 0 ? void 0 : commonValuesMap.set(commonValue, classPrefix);
                    }
                    else {
                        commonValuesMap === null || commonValuesMap === void 0 ? void 0 : commonValuesMap.delete(commonValue);
                        resolvedClasses.push(this.toTailwindClass(commonClassPrefix, commonValue));
                    }
                });
                valuesMap.forEach((classPrefix, value) => {
                    if (commonValuesMap === null || commonValuesMap === void 0 ? void 0 : commonValuesMap.has(value)) {
                        commonValuesMap.set(value, classPrefix);
                    }
                    else {
                        resolvedClasses.push(this.toTailwindClass(classPrefix, value));
                    }
                });
            }
        };
        Object.keys(targetObject).forEach(currentClassPrefix => {
            const objectValue = targetObject[currentClassPrefix];
            if ((0, isObject_1.isObject)(objectValue)) {
                const commonValuesMap = this.recursiveResolveClasses(objectValue, resolvedClasses);
                commonValuesMap.forEach((_, value, map) => {
                    map.set(value, currentClassPrefix);
                });
                intersectCommonValues(commonValuesMap);
            }
            else if (Array.isArray(objectValue)) {
                intersectCommonValues(new Map(objectValue.map(value => [value, currentClassPrefix])));
            }
        });
        return commonValuesMap || new Map();
    }
    toTailwindClass(classPrefix, value) {
        if (typeof value !== 'string') {
            value = value == null ? '' : value.toString();
        }
        if (value.startsWith('-')) {
            value = value.substring(1);
            classPrefix = `-${classPrefix}`;
        }
        return `${classPrefix}-${value}`;
    }
    parseTailwindClass(tailwindClass) {
        const isNegativeValue = tailwindClass.startsWith('-');
        if (isNegativeValue) {
            tailwindClass = tailwindClass.substring(1);
        }
        const lastDashIndex = tailwindClass.lastIndexOf('-');
        if (lastDashIndex === -1) {
            return {
                value: null,
                classPrefix: tailwindClass,
            };
        }
        const classPrefix = tailwindClass.slice(0, lastDashIndex);
        const absoluteValue = tailwindClass.slice(lastDashIndex + 1);
        return {
            value: isNegativeValue ? `-${absoluteValue}` : absoluteValue,
            classPrefix,
        };
    }
}
function reduceTailwindClasses(tailwindClasses) {
    const manager = new TailwindClassesReductionManager();
    tailwindClasses.forEach(className => {
        manager.appendClassName(className);
    });
    return manager.reduce();
}
exports.reduceTailwindClasses = reduceTailwindClasses;
