"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.converterMappingByTailwindTheme = exports.normalizeAtRuleParams = exports.normalizeSizeValue = exports.normalizeZeroSizeValue = exports.normalizeColorValue = exports.normalizeValue = void 0;
const colord_1 = require("colord");
const buildMediaQueryByScreen_1 = require("./buildMediaQueryByScreen");
const flattenObject_1 = require("./flattenObject");
const remValueToPx_1 = require("./remValueToPx");
const normalizeNumbersInString_1 = require("./normalizeNumbersInString");
const removeUnnecessarySpaces_1 = require("./removeUnnecessarySpaces");
function normalizeValue(value) {
    return (0, removeUnnecessarySpaces_1.removeUnnecessarySpaces)((0, normalizeNumbersInString_1.normalizeNumbersInString)(value));
}
exports.normalizeValue = normalizeValue;
function normalizeColorValue(colorValue) {
    const parsed = (0, colord_1.colord)(colorValue);
    return parsed.isValid() ? parsed.toHex() : colorValue;
}
exports.normalizeColorValue = normalizeColorValue;
function normalizeZeroSizeValue(value) {
    return value.trim() === '0px' ? '0' : value;
}
exports.normalizeZeroSizeValue = normalizeZeroSizeValue;
function normalizeSizeValue(sizeValue, remInPx) {
    return normalizeZeroSizeValue((0, normalizeNumbersInString_1.normalizeNumbersInString)(remInPx != null ? (0, remValueToPx_1.remValueToPx)(sizeValue, remInPx) : sizeValue));
}
exports.normalizeSizeValue = normalizeSizeValue;
function normalizeAtRuleParams(atRuleParam) {
    return (0, removeUnnecessarySpaces_1.removeUnnecessarySpaces)(atRuleParam.replace(/\(|\)/g, ''));
}
exports.normalizeAtRuleParams = normalizeAtRuleParams;
function mapThemeTokens(tokens, valueConverterFn) {
    const result = {};
    Object.keys(tokens).forEach(tokenKey => {
        const tokenValue = tokens[tokenKey];
        const convertedTokenValue = valueConverterFn(tokenValue, tokenKey);
        if (convertedTokenValue) {
            result[convertedTokenValue] = tokenKey;
        }
    });
    return result;
}
function isColorKey(key) {
    return (['fill', 'stroke'].includes(key) || key.toLowerCase().includes('color'));
}
function isSizeKey(key) {
    return [
        'backdropBlur',
        'backgroundSize',
        'blur',
        'borderRadius',
        'borderSpacing',
        'borderWidth',
        'columns',
        'divideWidth',
        'flexBasis',
        'gap',
        'height',
        'inset',
        'letterSpacing',
        'lineHeight',
        'margin',
        'maxHeight',
        'maxWidth',
        'minHeight',
        'minWidth',
        'outlineOffset',
        'outlineWidth',
        'padding',
        'ringOffsetWidth',
        'ringWidth',
        'scrollMargin',
        'scrollPadding',
        'space',
        'spacing',
        'strokeWidth',
        'textDecorationThickness',
        'textUnderlineOffset',
        'translate',
        'width',
    ].includes(key);
}
function convertFontSizes(fontSizes, remInPx) {
    return mapThemeTokens(fontSizes, fontSizeValue => {
        if (!fontSizeValue) {
            return null;
        }
        if (Array.isArray(fontSizeValue)) {
            fontSizeValue = fontSizeValue[0];
        }
        return normalizeSizeValue(fontSizeValue, remInPx);
    });
}
function convertScreens(screens) {
    if (Array.isArray(screens)) {
        return {};
    }
    return mapThemeTokens(screens, screenValue => {
        return screenValue
            ? normalizeAtRuleParams((0, buildMediaQueryByScreen_1.buildMediaQueryByScreen)(screenValue))
            : null;
    });
}
function convertColors(colors) {
    const flatColors = (0, flattenObject_1.flattenObject)(colors);
    return mapThemeTokens(flatColors, (colorValue) => {
        colorValue = colorValue === null || colorValue === void 0 ? void 0 : colorValue.toString();
        return colorValue ? normalizeColorValue(colorValue) : null;
    });
}
function convertSizes(sizes, remInPx) {
    return mapThemeTokens(sizes, (sizeValue) => {
        sizeValue = sizeValue === null || sizeValue === void 0 ? void 0 : sizeValue.toString();
        return sizeValue ? normalizeSizeValue(sizeValue, remInPx) : null;
    });
}
function convertOtherThemeTokens(tokens) {
    return tokens
        ? mapThemeTokens(tokens, (tokenValue) => {
            tokenValue = tokenValue === null || tokenValue === void 0 ? void 0 : tokenValue.toString();
            return tokenValue ? normalizeValue(tokenValue) : null;
        })
        : tokens;
}
function converterMappingByTailwindTheme(resolvedTailwindTheme, remInPx) {
    const converterMapping = {};
    if (!resolvedTailwindTheme) {
        return converterMapping;
    }
    Object.keys(resolvedTailwindTheme).forEach(key => {
        if (['keyframes', 'container', 'fontFamily'].includes(key)) {
            return;
        }
        const themeItem = resolvedTailwindTheme[key];
        if (key === 'fontSize') {
            converterMapping[key] = convertFontSizes(themeItem, remInPx);
        }
        else if (key === 'screens') {
            converterMapping[key] = convertScreens(themeItem);
        }
        else if (isColorKey(key)) {
            converterMapping[key] = convertColors(themeItem);
        }
        else if (isSizeKey(key)) {
            converterMapping[key] = convertSizes(themeItem, remInPx);
        }
        else {
            converterMapping[key] = convertOtherThemeTokens(themeItem);
        }
    });
    return converterMapping;
}
exports.converterMappingByTailwindTheme = converterMappingByTailwindTheme;
