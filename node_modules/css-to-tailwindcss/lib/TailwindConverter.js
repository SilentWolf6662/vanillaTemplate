"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TailwindConverter = exports.DEFAULT_CONVERTER_CONFIG = void 0;
const postcss_1 = __importStar(require("postcss"));
const postcss_safe_parser_1 = __importDefault(require("postcss-safe-parser"));
const css_what_1 = require("css-what");
const TailwindNodesManager_1 = require("./TailwindNodesManager");
const isAtRuleNode_1 = require("./utils/isAtRuleNode");
const converterMappingByTailwindTheme_1 = require("./utils/converterMappingByTailwindTheme");
const declaration_converters_mapping_1 = require("./mappings/declaration-converters-mapping");
const isChildNode_1 = require("./utils/isChildNode");
const media_params_mapping_1 = require("./mappings/media-params-mapping");
const removeUnnecessarySpaces_1 = require("./utils/removeUnnecessarySpaces");
const reduceTailwindClasses_1 = require("./utils/reduceTailwindClasses");
const pseudos_mapping_1 = require("./mappings/pseudos-mapping");
const detectIndent_1 = require("./utils/detectIndent");
const resolveConfig_1 = require("./utils/resolveConfig");
exports.DEFAULT_CONVERTER_CONFIG = {
    postCSSPlugins: [],
    arbitraryPropertiesIsEnabled: false,
};
class TailwindConverter {
    constructor(_a = {}) {
        var { tailwindConfig } = _a, converterConfig = __rest(_a, ["tailwindConfig"]);
        const resolvedTailwindConfig = (0, resolveConfig_1.resolveConfig)(tailwindConfig || { content: [] });
        this.config = Object.assign(Object.assign(Object.assign({}, exports.DEFAULT_CONVERTER_CONFIG), converterConfig), { tailwindConfig: resolvedTailwindConfig, mapping: (0, converterMappingByTailwindTheme_1.converterMappingByTailwindTheme)(resolvedTailwindConfig.theme, converterConfig.remInPx) });
    }
    convertCSS(css) {
        return __awaiter(this, void 0, void 0, function* () {
            const nodesManager = new TailwindNodesManager_1.TailwindNodesManager();
            const parsed = yield (0, postcss_1.default)(this.config.postCSSPlugins).process(css, {
                parser: postcss_safe_parser_1.default,
            });
            parsed.root.walkRules(rule => {
                const converted = this.convertRule(rule);
                if (converted) {
                    nodesManager.mergeNode(converted);
                }
            });
            const nodes = nodesManager.getNodes();
            nodes.forEach(node => {
                if (node.tailwindClasses.length) {
                    node.rule.prepend(new postcss_1.AtRule({
                        name: 'apply',
                        params: node.tailwindClasses.join(' '),
                    }));
                }
            });
            this.cleanRaws(parsed.root);
            return {
                nodes,
                convertedRoot: parsed.root,
            };
        });
    }
    cleanRaws(root) {
        root.raws.indent = (0, detectIndent_1.detectIndent)(root);
        root.walkRules(node => {
            var _a;
            if (((_a = node.nodes) === null || _a === void 0 ? void 0 : _a.length) === 0) {
                node.remove();
            }
            else {
                node.cleanRaws(true);
            }
        });
        root.walkAtRules(node => {
            var _a;
            if (((_a = node.nodes) === null || _a === void 0 ? void 0 : _a.length) === 0) {
                node.remove();
            }
            else {
                node.cleanRaws(true);
            }
        });
    }
    convertRule(rule) {
        let tailwindClasses = [];
        rule.walkDecls(declaration => {
            const converted = this.convertDeclarationToClasses(declaration);
            if (converted === null || converted === void 0 ? void 0 : converted.length) {
                declaration.remove();
                tailwindClasses = tailwindClasses.concat(converted);
            }
        });
        if (tailwindClasses.length) {
            tailwindClasses = (0, reduceTailwindClasses_1.reduceTailwindClasses)(tailwindClasses);
            if (this.config.tailwindConfig.prefix) {
                tailwindClasses = tailwindClasses.map(className => className[0] === '[' // is "arbitrary property" class
                    ? className
                    : `${this.config.tailwindConfig.prefix}${className}`);
            }
            return this.makeTailwindNode(rule, tailwindClasses);
        }
        return null;
    }
    convertDeclarationToClasses(declaration) {
        var _a;
        let classes = ((_a = declaration_converters_mapping_1.DECLARATION_CONVERTERS_MAPPING[declaration.prop]) === null || _a === void 0 ? void 0 : _a.call(declaration_converters_mapping_1.DECLARATION_CONVERTERS_MAPPING, declaration, this.config)) || [];
        if (classes.length === 0 && this.config.arbitraryPropertiesIsEnabled) {
            return [
                `[${declaration.prop}:${(0, declaration_converters_mapping_1.prepareArbitraryValue)(declaration.value)}]`,
            ];
        }
        return classes;
    }
    makeTailwindNode(rule, tailwindClasses) {
        let { baseSelector, classPrefix } = this.parseSelector(rule.selector);
        const classPrefixByParentNodes = this.convertContainerToClassPrefix(rule.parent);
        if (classPrefixByParentNodes) {
            return {
                key: baseSelector,
                rootRuleSelector: baseSelector,
                originalRule: rule,
                classesPrefix: classPrefixByParentNodes + classPrefix,
                tailwindClasses,
            };
        }
        if (classPrefix) {
            const key = TailwindNodesManager_1.TailwindNodesManager.convertRuleToKey(rule, baseSelector);
            const isRootRule = key === baseSelector;
            return {
                key: key,
                rootRuleSelector: isRootRule ? baseSelector : null,
                originalRule: rule,
                classesPrefix: classPrefix,
                tailwindClasses,
            };
        }
        return { rule, tailwindClasses };
    }
    parseSelector(rawSelector) {
        const parsedSelectors = (0, css_what_1.parse)(rawSelector);
        if (parsedSelectors.length !== 1) {
            return { baseSelector: rawSelector, classPrefix: '' };
        }
        const parsedSelector = parsedSelectors[0];
        let baseSelectors = [];
        let classPrefixes = [];
        parsedSelector === null || parsedSelector === void 0 ? void 0 : parsedSelector.forEach((selectorItem, index) => {
            if ((0, css_what_1.isTraversal)(selectorItem)) {
                baseSelectors = parsedSelector.slice(0, index + 1);
                classPrefixes = [];
                return;
            }
            const classPrefix = this.convertSelectorToClassPrefix(selectorItem);
            if (classPrefix) {
                classPrefixes.push(classPrefix);
            }
            else {
                baseSelectors.push(selectorItem);
            }
        });
        return {
            baseSelector: (0, css_what_1.stringify)([baseSelectors]),
            classPrefix: classPrefixes.join(''),
        };
    }
    convertSelectorToClassPrefix(selector) {
        var _a, _b;
        if (selector.type === 'pseudo' || selector.type === 'pseudo-element') {
            const mapped = pseudos_mapping_1.PSEUDOS_MAPPING[selector.name];
            return mapped ? `${mapped}${this.config.tailwindConfig.separator}` : null;
        }
        if (selector.type === 'attribute') {
            if (selector.name.startsWith('aria-')) {
                const mappingKey = this.attributeSelectorToMappingKey(selector, 6);
                const mapped = (_a = this.config.mapping.aria) === null || _a === void 0 ? void 0 : _a[mappingKey];
                if (!mapped) {
                    return null;
                }
                return `${mapped}${this.config.tailwindConfig.separator}`;
            }
            if (selector.name.startsWith('data-')) {
                const mappingKey = this.attributeSelectorToMappingKey(selector, 6);
                const mapped = (_b = this.config.mapping.data) === null || _b === void 0 ? void 0 : _b[mappingKey];
                if (!mapped) {
                    return null;
                }
                return `${mapped}${this.config.tailwindConfig.separator}`;
            }
        }
        return null;
    }
    attributeSelectorToMappingKey(selector, from = 1) {
        const stringifiedSelector = (0, css_what_1.stringify)([[selector]]);
        return stringifiedSelector.substring(from, stringifiedSelector.length - 1);
    }
    convertContainerToClassPrefix(container) {
        let currentContainer = container;
        const mediaParams = [];
        const supportsParams = [];
        while ((0, isChildNode_1.isChildNode)(currentContainer)) {
            if (!(0, isAtRuleNode_1.isAtRuleNode)(currentContainer)) {
                // do not convert if parent is not at-rule
                return '';
            }
            if (currentContainer.name === 'media') {
                mediaParams.push(currentContainer.params);
            }
            else if (currentContainer.name === 'supports') {
                supportsParams.push(currentContainer.params);
            }
            else {
                return '';
            }
            currentContainer = currentContainer.parent;
        }
        let mediaPrefixes = '', supportsPrefixes = '';
        if (mediaParams.length) {
            mediaPrefixes = this.convertMediaParamsToClassPrefix(mediaParams.reverse());
            if (!mediaPrefixes) {
                return '';
            }
        }
        if (supportsParams.length) {
            supportsPrefixes = this.convertSupportsParamsToClassPrefix(supportsParams.reverse());
            if (!supportsPrefixes) {
                return '';
            }
        }
        return mediaPrefixes + supportsPrefixes;
    }
    convertMediaParamsToClassPrefix(mediaParams) {
        const modifiers = [];
        const screens = [];
        for (let i = 0; i < mediaParams.length; i++) {
            const splitted = mediaParams[i].split(' and ');
            for (let j = 0; j < splitted.length; j++) {
                const param = (0, converterMappingByTailwindTheme_1.normalizeAtRuleParams)(splitted[j].trim());
                if (param === 'screen') {
                    continue;
                }
                if (param.includes('width') || param.includes('height')) {
                    screens.push(param);
                    continue;
                }
                let mapped = media_params_mapping_1.MEDIA_PARAMS_MAPPING[param.replace(/\s+/g, '')];
                if (mapped) {
                    modifiers.push(mapped);
                    continue;
                }
                // do not convert if not convertable media
                return '';
            }
        }
        if (screens.length > 0) {
            const mappedScreen = this.config.mapping.screens[screens.join(' and ')];
            if (!mappedScreen) {
                return '';
            }
            modifiers.push(mappedScreen);
        }
        const classPrefix = modifiers.join(this.config.tailwindConfig.separator);
        return classPrefix
            ? classPrefix + this.config.tailwindConfig.separator
            : '';
    }
    convertSupportsParamsToClassPrefix(supportParams) {
        const buildParams = supportParams.join(' and ');
        const classPrefix = (0, declaration_converters_mapping_1.convertDeclarationValue)(supportParams.length > 1
            ? (0, removeUnnecessarySpaces_1.removeUnnecessarySpaces)(buildParams)
            : (0, converterMappingByTailwindTheme_1.normalizeAtRuleParams)(buildParams), this.config.mapping.supports || {}, 'supports');
        return classPrefix
            ? classPrefix + this.config.tailwindConfig.separator
            : '';
    }
}
exports.TailwindConverter = TailwindConverter;
